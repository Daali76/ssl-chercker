"""
Vulnerability Scanner Service
Scans domains for open ports and vulnerabilities using public APIs
"""

import logging
import aiohttp
import asyncio
import json
from typing import Dict, List, Optional
from datetime import datetime

logger = logging.getLogger(__name__)

class VulnerabilityScanner:
    """
    Scan domains for:
    - Open ports
    - Known vulnerabilities
    - Security headers
    - SSL/TLS configuration
    """
    
    def __init__(self, shodan_api_key: Optional[str] = None):
        self.shodan_api_key = shodan_api_key
        self.timeout = aiohttp.ClientTimeout(total=10)
    
    async def scan_domain(self, hostname: str) -> Dict:
        """
        Comprehensive vulnerability scan for a domain
        Returns: {
            'hostname': str,
            'ports': List of open ports,
            'vulnerabilities': List of known CVEs,
            'ssl_rating': A+ to F,
            'headers_check': security headers present,
            'dns_records': MX, SPF, DMARC info,
            'scan_time': timestamp
        }
        """
        hostname = hostname.replace("https://", "").replace("http://", "").split("/")[0]
        
        results = {
            "hostname": hostname,
            "scan_time": datetime.utcnow().isoformat(),
            "ports": await self._scan_ports(hostname),
            "vulnerabilities": await self._check_vulnerabilities(hostname),
            "ssl_rating": await self._check_ssl_rating(hostname),
            "headers": await self._check_security_headers(hostname),
            "dns_records": await self._check_dns_security(hostname)
        }
        
        return results
    
    async def _scan_ports(self, hostname: str) -> Dict:
        """
        Scan common ports using free port scanning APIs
        Uses: https://api.hackertarget.com/nmap/
        """
        try:
            url = f"https://api.hackertarget.com/nmap/?q={hostname}"
            async with aiohttp.ClientSession(timeout=self.timeout) as session:
                async with session.get(url) as resp:
                    if resp.status == 200:
                        text = await resp.text()
                        ports = self._parse_nmap_output(text)
                        return {
                            "open": ports,
                            "total_scanned": len(ports),
                            "source": "hackertarget.com"
                        }
        except Exception as e:
            logger.error(f"Port scan error for {hostname}: {e}")
        
        return {"open": [], "total_scanned": 0, "error": "Scan failed"}
    
    async def _check_vulnerabilities(self, hostname: str) -> List[Dict]:
        """
        Check for known vulnerabilities using multiple sources
        """
        vulnerabilities = []
        
        # 1. Check with cvedetails-like API
        vulns = await self._check_cve_details(hostname)
        vulnerabilities.extend(vulns)
        
        # 2. Check SSL vulnerabilities
        ssl_vulns = await self._check_ssl_vulnerabilities(hostname)
        vulnerabilities.extend(ssl_vulns)
        
        return vulnerabilities
    
    async def _check_cve_details(self, hostname: str) -> List[Dict]:
        """
        Check CVE database for known vulnerabilities
        Uses: https://api.hackertarget.com/hostsearch/
        """
        try:
            url = f"https://api.hackertarget.com/hostsearch/?q={hostname}"
            async with aiohttp.ClientSession(timeout=self.timeout) as session:
                async with session.get(url) as resp:
                    if resp.status == 200:
                        text = await resp.text()
                        # Parse results and check against known vulnerable domains
                        if "API rate limit" not in text:
                            return []
        except Exception as e:
            logger.debug(f"CVE check error: {e}")
        
        return []
    
    async def _check_ssl_vulnerabilities(self, hostname: str) -> List[Dict]:
        """
        Check SSL/TLS for known issues:
        - Heartbleed
        - POODLE
        - CCS Injection
        - etc.
        """
        vulnerabilities = []
        
        try:
            # Use SSL Labs API (free tier available)
            url = f"https://api.ssllabs.com/api/v3/analyze?host={hostname}&publish=off"
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=30)) as session:
                async with session.get(url) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        
                        # Check certificate issues
                        if "certs" in data:
                            cert = data["certs"][0]
                            if cert.get("issues"):
                                vulnerabilities.append({
                                    "type": "SSL_CERTIFICATE_ISSUE",
                                    "severity": "medium",
                                    "details": cert["issues"]
                                })
                        
                        # Check protocol support
                        if "endpoints" in data:
                            for endpoint in data["endpoints"]:
                                if endpoint.get("supportsSSLv3"):
                                    vulnerabilities.append({
                                        "type": "LEGACY_PROTOCOL",
                                        "severity": "high",
                                        "protocol": "SSLv3"
                                    })
                                if endpoint.get("supportsTLS10"):
                                    vulnerabilities.append({
                                        "type": "WEAK_PROTOCOL",
                                        "severity": "medium",
                                        "protocol": "TLSv1.0"
                                    })
        except Exception as e:
            logger.debug(f"SSL Labs API error: {e}")
        
        return vulnerabilities
    
    async def _check_ssl_rating(self, hostname: str) -> Dict:
        """
        Get SSL/TLS rating (A+ to F) from SSL Labs
        """
        try:
            url = f"https://api.ssllabs.com/api/v3/analyze?host={hostname}&publish=off"
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=30)) as session:
                async with session.get(url) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        if "endpoints" in data and len(data["endpoints"]) > 0:
                            grade = data["endpoints"][0].get("grade", "UNKNOWN")
                            return {
                                "rating": grade,
                                "score": self._grade_to_score(grade),
                                "source": "ssllabs.com"
                            }
        except Exception as e:
            logger.debug(f"SSL rating check error: {e}")
        
        return {"rating": "UNKNOWN", "score": 0}
    
    async def _check_security_headers(self, hostname: str) -> Dict:
        """
        Check for security headers:
        - HSTS
        - CSP
        - X-Frame-Options
        - X-Content-Type-Options
        - Referrer-Policy
        """
        headers_found = {}
        critical_headers = {
            "Strict-Transport-Security": "HSTS",
            "Content-Security-Policy": "CSP",
            "X-Frame-Options": "X-Frame-Options",
            "X-Content-Type-Options": "X-Content-Type-Options",
            "Referrer-Policy": "Referrer-Policy",
            "X-XSS-Protection": "X-XSS-Protection"
        }
        
        try:
            url = f"https://{hostname}"
            async with aiohttp.ClientSession(timeout=self.timeout) as session:
                async with session.head(url, allow_redirects=True, ssl=False) as resp:
                    for header, name in critical_headers.items():
                        if header in resp.headers:
                            headers_found[name] = resp.headers[header]
        except Exception as e:
            logger.debug(f"Security headers check error: {e}")
        
        missing = set(critical_headers.values()) - set(headers_found.keys())
        
        return {
            "found": headers_found,
            "missing": list(missing),
            "score": len(headers_found)
        }
    
    async def _check_dns_security(self, hostname: str) -> Dict:
        """
        Check DNS security records:
        - SPF (Sender Policy Framework)
        - DMARC (Domain-based Message Authentication)
        - DNSSEC
        """
        import socket
        
        dns_info = {
            "mx_records": [],
            "spf": None,
            "dmarc": None,
            "dnssec": None
        }
        
        try:
            # Try to get MX records
            import subprocess
            result = subprocess.run(
                ["dig", f"{hostname}", "MX", "+short"],
                capture_output=True,
                text=True,
                timeout=5
            )
            if result.stdout:
                dns_info["mx_records"] = result.stdout.strip().split("\n")
            
            # Check SPF
            spf_result = subprocess.run(
                ["dig", f"{hostname}", "TXT", "+short"],
                capture_output=True,
                text=True,
                timeout=5
            )
            if "v=spf1" in spf_result.stdout:
                dns_info["spf"] = "Found"
            
            # Check DMARC
            dmarc_result = subprocess.run(
                ["dig", f"_dmarc.{hostname}", "TXT", "+short"],
                capture_output=True,
                text=True,
                timeout=5
            )
            if "v=DMARC1" in dmarc_result.stdout:
                dns_info["dmarc"] = "Found"
        
        except Exception as e:
            logger.debug(f"DNS security check error: {e}")
        
        return dns_info
    
    def _parse_nmap_output(self, output: str) -> List[Dict]:
        """Parse nmap output and extract open ports"""
        ports = []
        for line in output.split("\n"):
            line = line.strip()
            if "open" in line and "/" in line:
                parts = line.split()
                if len(parts) >= 2:
                    try:
                        port_num = int(parts[0].split("/")[0])
                        service = parts[1] if len(parts) > 1 else "unknown"
                        ports.append({
                            "port": port_num,
                            "service": service,
                            "status": "open"
                        })
                    except ValueError:
                        continue
        return ports
    
    def _grade_to_score(self, grade: str) -> int:
        """Convert SSL Labs grade to numeric score"""
        grades = {
            "A+": 95, "A": 90, "A-": 85,
            "B": 70, "C": 50, "D": 30,
            "E": 15, "F": 0, "T": 0, "M": 0,
            "UNKNOWN": 0
        }
        return grades.get(grade, 0)


# Singleton instance
_scanner = None

async def get_vulnerability_scanner(shodan_api_key: Optional[str] = None) -> VulnerabilityScanner:
    """Get or create vulnerability scanner instance"""
    global _scanner
    if _scanner is None:
        _scanner = VulnerabilityScanner(shodan_api_key)
    return _scanner
